#pragma option w32c
#pragma option P
#pragma option J1
#pragma option X
#include <windows.h>
#include "msvcrt.h"

//Сделать так, чтобы на создаваемых файлах не устанавливался флаг "r"
//Добавить массив (сигнатура, смещение)
//массив номер версии в двоичном формате (старший, младший номера)

//Добавить функцию по занесению в спецпапку(рандомом имя генерируется) ошибочных файлов (обработать повторные имена: как-то изменить)

//Дельфины.exe SIG_V4_7	37582406h
//SEEK_V4_7	46000h

//Рыбка в аквариуме.exe SIG_V3_8	353D0FDDh
//SEEK_V3_8	24000h

//	!!!!!!!!!!!!!


#define	SIG_V4		6010Bh
#define	SEEK_V4		46000h

#define	SIG_V5_30D	399C98BDh
#define	SEEK_V5_30D8	58000h
#define	SEEK_V5_30DC	5C000h

#define	SIG_V5_30C	399C998Ch
#define	SEEK_V5_30C9	59000h
#define	SEEK_V5_30CF	5F000h
#define	SEEK_V5_30C6	69000h

#define	SIG_V6_4	3C74E454h
#define	SEEK_V6_4	0C6000h

#define	SIG_V6_21	3C85AAA3h
#define	SEEK_V6_21B7	0B7000h
#define	SEEK_V6_21BC	0BC000h
#define	SEEK_V6_21C8	0C8000h

#define	SIG_V7_14	3F57AD38h
#define	SEEK_V7_14	0F1000h

#define	SIG_V7_19	3FD4F616h
#define	SEEK_V7_19	0F5000h

#define	SIG_V8_22	4310D1EEh
#define	SEEK_V8_22	182000h

//кол-во МБайт читаем
#define	MAXBYTEREAD	18*1048576

#define DEBUG 0

enum { ErrName= 1, ErrParam, ErrOpen, ErrInfo, ErrOffset, ErrSeek, ErrSig, ErrCreate };

dword	fHANDL, nHANDL, sHANDL, SetSeek, pSeek, CNT_Byte, ErrLev, k;
char *pPrm;

struct sett_extract {
	char quiet;
	char batch;
};

sett_extract sett;

#define EX_PATH MAX_PATH*16

byte sName[EX_PATH],  swfName[EX_PATH];
WIN32_FILE_ATTRIBUTE_DATA FlInf;
WIN32_FIND_DATA Find;
byte Buff[MAXBYTEREAD];

int main()
{
	printf("EXE--> SWF Extractor 1v4.1\nHistory: 04.10.06 30.05.07 13.01.08 04.05.08 14.09.08 16.09.08 20.09.08\n29.10.08 03.11.08 02.12.08\n\t\t(c) Simron\n\n");
	sett.quiet= 0;
	sett.batch= 1;
	ErrLev= 0;

 	FOR(k= 0; k++< __numparam;){
		pPrm= @PARAMSTR(k);
 		IF(!strcmp(pPrm, "-q")) { sett.quiet= 1; CONTINUE; }
		IF(!strcmp(pPrm, "-m")) { sett.batch= 0; CONTINUE; }
		printf("Unknown cmd \"%s\"\n", pPrm);
		ErrLev= ErrParam;
 	}
 	IF(DEBUG) printf("quiet: %d\nbatch: %d\n", sett.quiet, sett.batch);
 	IF(ErrLev) GOTO localExit;

	EDI= -1;
	IF(sett.batch) {
		IF( sHANDL= FindFirstFile("*.exe", #Find)== EDI )
		{
			printf("No files found\n");
		localExit:
			goto ExitMain;
		}
	}

	FOR(;;)
	{
		IF(!sett.batch) {
		NewRecord:
			IF(!gets(#sName))	break;
			DSBYTE[#sName- 1+ EX_PATH]= 0;
			IF(DEBUG) printf("\ngets:\t\"%s\"\n", #sName);
			OemToChar(#sName, #Find.cFileName);
			IF(!GetFileAttributesEx(#Find.cFileName, GetFileExInfoStandard, #FlInf)) {
				printf("Erorr info \"%s\"\n", #sName);
				ErrLev= ErrInfo;
				GOTO NewRecord;
			}
			Find.nFileSizeLow= FlInf.nFileSizeLow;
			IF(DEBUG) printf("\nAfter GetFileAttr..:\t\"%s\"\n\n", #sName);
		}
		IF(Find.nFileSizeLow< 244000)	goto NextFile;
		IF(sett.batch) CharToOem(#Find.cFileName, #sName);

		if( fHANDL= _lopen(#Find.cFileName, OF_READ) != EDI)
		{
			_lread(fHANDL, #Buff, MAXBYTEREAD);
			SetSeek= 0;
			EBX= #Buff+8+ DSDWORD[#Buff+ 3Ch];
			switch(DSDWORD[EBX])
			{
				CASE SIG_V4:		SetSeek= SEEK_V4; break;
				CASE SIG_V5_30D:
						EAX= DSDWORD[#Buff+ SEEK_V5_30D8];
						EAX&= 0FFFFFFh;
						IF( (EAX== 'SWC')||(EAX== 'SWF') )	SetSeek= SEEK_V5_30D8;
						ELSE SetSeek= SEEK_V5_30DC;
						break;
				CASE SIG_V5_30C:
						EAX= DSDWORD[#Buff+ SEEK_V5_30C9];
						EAX&= 0FFFFFFh;
						IF( (EAX== 'SWC')||(EAX== 'SWF') )	SetSeek= SEEK_V5_30C9;
						ELSE
						{
							EAX= DSDWORD[#Buff+ SEEK_V5_30CF];
							EAX&= 0FFFFFFh;
							IF( (EAX== 'SWC')||(EAX== 'SWF') ) SetSeek= SEEK_V5_30CF;
							ELSE SetSeek= SEEK_V5_30C6;
						}
						break;
				case SIG_V6_4:		SetSeek= SEEK_V6_4; BREAK;
				case SIG_V6_21:
						EAX= DSDWORD[#Buff+ SEEK_V6_21B7];
						EAX&= 0FFFFFFh;
						IF( (EAX== 'SWC')||(EAX== 'SWF') )	SetSeek= SEEK_V6_21B7;
						ELSE
						{
							EAX= DSDWORD[#Buff+ SEEK_V6_21BC];
							EAX&= 0FFFFFFh;
							IF( (EAX== 'SWC')||(EAX== 'SWF') ) SetSeek= SEEK_V6_21BC;
							ELSE SetSeek= SEEK_V6_21C8;
						}
						BREAK;
				case SIG_V7_14:		SetSeek= SEEK_V7_14; BREAK;
				case SIG_V7_19:		SetSeek= SEEK_V7_19; BREAK;
				case SIG_V8_22:		SetSeek= SEEK_V8_22; BREAK;
			}
			if(SetSeek)
			{
				pSeek= #Buff+ SetSeek;
				EAX= DSDWORD[pSeek];
				EAX&= 0FFFFFFh;
				if( (EAX== 'SWC')||(EAX== 'SWF') )
				{
					EBX= #Find.cFileName-4+ strlen(#sName);
					DSDWORD[EBX]= 'fws.';
					CharToOem(#Find.cFileName, #swfName);
					printf("Create..\t\"%s\"\n", #swfName);
					IF( nHANDL= _lcreat(#Find.cFileName, 1)!= EDI)
					{
						CNT_Byte= Find.nFileSizeLow- SetSeek;
						SetSeek= _lwrite(nHANDL, pSeek, CNT_Byte);
						IF(SetSeek!= CNT_Byte) { ErrLev= ErrSeek; printf("Error write in \"%s\"\n", #swfName); }
						ELSE printf("Write in\t\"%s\"\t\t%dB\n", #swfName, SetSeek);
						_lclose(nHANDL);
					}
					ELSE { ErrLev= ErrCreate; printf("No create \"%s\"\n", #swfName); }
					DSDWORD[pSeek]= 0;
				}
				ELSE { ErrLev= ErrSig; printf("Error swf-sig in \"%s\"\n", #sName); }
			}
			ELSE { ErrLev= ErrOffset; printf("Error offset in \"%s\"\n", #sName); }
			_lclose(fHANDL);
		}
		ELSE { ErrLev= ErrOpen; printf("Error open \"%s\"\n", #Find.cFileName); }
	NextFile:
		IF( (sett.batch)&&(!FindNextFile(sHANDL, #Find)) ) BREAK;
	}
	IF(sett.batch) FindClose(sHANDL);

	printf("Finish\n\n");
ExitMain:
	IF(!sett.quiet)	_getch();
	return ErrLev;
}